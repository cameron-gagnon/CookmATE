from alexa.ask import voice, Request, ResponseBuilder as r

import recipe
import scrape
import json
import decimal
import boto3

"""
In this file we specify default event handlers which are then populated into the handler map using metaprogramming
Copyright Anjishnu Kumar 2015

Each VoiceHandler function receives a Request object as input and outputs a Response object 
A response object is defined as the output of ResponseBuilder.create_response()
"""


def lambda_handler(request_obj, context={}):
    '''      
    This is the main function to enter to enter into this code. 
    If you are hosting this code on AWS Lambda, this should be the entry point. 
    Otherwise your server can hit this code as long as you remember that the
    input 'request_obj' is JSON request converted into a nested python object.        
    '''

    request = Request(request_obj)

    ''' inject user relevant metadata into the request if you want to, here.
    
    e.g. Something like : 
    ... request.meta_data['user_name'] = some_database.query_user_name(request.get_user_id()) 
    
    Then in the handler function you can do something like -
    ... return r.create_response('Hello there {}!'.format(request.meta_data['user_name']))
    '''    
    return voice.route_request(request)

    
@voice.default_handler()
def default_handler(request):
    """ The default handler gets invoked if no handler is set for a request """
    outMessage = "I can find you a recipe, list your recipes, or load a custom recipe."
    return r.create_response(message=outMessage)



@voice.request_handler("LaunchRequest")
def launch_request_handler(request):
    """
    Annotate functions with @VoiceHandler so that they can be automatically mapped 
    to request types.
    Use the 'request_type' field to map them to non-intent requests
    """
    outMessage = "Hello! I'm Cookmate, your best friend in the kitchen! " +\
                 "I can help you find a recipe for a meal, list your recipes, or " +\
                 "load a custom recipe of yours!"
    return r.create_response(message=outMessage)


@voice.request_handler(request_type="SessionEndedRequest")
def session_ended_request_handler(request):
    return r.create_response(message="Goodbye!")


@voice.intent_handler(intent='LoadRecipeIntent')
def get_recipe_intent_handler(request):
    """
    Use the 'intent' field in the VoiceHandler to map to the respective intent.
    You can insert arbitrary business logic code here    
    """

    # Get variables like userId, slots, intent name etc from the 'Request' object
    recipe = request.get_slot_value("LoadRecipe") 
    recipe = recipe if recipe else ""

    outMessage = "Are you ready to hear the ingredients for your {} recipe?".format(recipe)
    return r.create_response(message=outMessage)


@voice.intent_handler(intent="FindRecipeIntent")
def next_recipe_intent_handler(request):
    """
        gets the top three URLS for the desired type of recipes
    """
    food = request.get_slot_value("FindRecipe")

    # go find a recipe
    webPage = scrape.FindRecipe(food)
    webPage.storeTopFive()
    top3 = webPage.returnTopFive()
    
    db = Database(request.user_id())
    db.updateLinks(top3)

    outMessage = "The top 3 {0} recipes are: {1}, {2}, and {3}.".format(food,
                                                                       top3[0][0],
                                                                       top3[1][0],
                                                                       top3[2][0])
    outMessage += " Which one would you like to make?"
    rePrompt = "Please pick an option 1 through 3."

    return r.create_response(message=outMessage, reprompt_message=rePrompt)

@voice.intent_handler(intent="ChoiceIntent")
def choose_recipe_intent_handler(request):
    """
        Gets the information for the next recipe that they will be making
    """
    # check for no recipe specified yet
    
    choiceNum = request.get_slot_value("Choice")

    if ((1 <= int(choiceNum)) and (int(choiceNum) <= 3)):
        print("INSIDE CHOICE")

        db = Database(request.user_id())
        db.updateChoice(choiceNum)
        link = db.getLink(choiceNum)

        print("LINK IS: " + link)


    outMessage = "Say: begin recipe to start, or cancel to end."

    return r.create_response(message=outMessage);



@voice.intent_handler(intent="NextIntent")
def begin_recipe_intent(request):
    """
        Plays the first ingredient
    """

    outMessage =  "HAVE TO QUERY THE DATABASE STILL for indices"
    db = Database(request.user_id())

    if (db.getIngredNum() > 0):
        outMessage = db.getNextIngredient()
    elif (db.getStepNum() > 0):
        outMessage = db.getNextStep()

    return r.create_response(message=outMessage);

class Database:

    TABLENAME = "Link"
    LINK = ""

    def __init__(self, user_id = None):
        self.client = boto3.client('dynamodb')
        self.user_id = user_id

    def updateChoice(self, choiceNum): 
        """
            update the users choice
        """
        self.client.update_item(TableName=self.TABLENAME,
                        Key={
                        "UserID": {"S": self.user_id},
                    },
                        UpdateExpression="SET Choice = :val1",
                        ExpressionAttributeValues={
                        ':val1': {"N": choiceNum}
                    },
                        ReturnValues="UPDATED_NEW"
                    )

    def updateLinks(self, top3):
        response = self.client.update_item(TableName=self.TABLENAME,
                    Key={
                        "UserID": {"S": self.user_id},
                    },
                    UpdateExpression="set URLS = :a",
                    ExpressionAttributeValues={
                        ":a": {"SS": [top3[0][1],
                                      top3[1][1],
                                      top3[2][1]
                                     ]
                            }
                        },
                    ReturnValues="UPDATED_NEW"
                )

    def getLink(self, choiceNum):
        """
            gets the top 3 links for the specific recipe
        """
        results = self.client.get_item(TableName=self.TABLENAME,
                    Key={
                    "UserID": {"S": self.user_id}
                },
                    ProjectionExpression="URLS"
                )

        self.LINK = results['Item']['URLS']['SS'][int(choiceNum) - 1]
        return self.LINK

    def getNextIngredient(self):
        results = self.client.get_item(TableName=self.TABLENAME,
                    Key={
                    "UserID": {"S": self.user_id}
                },
                    ProjectionExpression="Ingreds, Choice"
                )
        ingStep = results['Item']['Ingstep']['N']

        return results['Item']['Ingreds']['SS'][ingStep]

    def getNextStep(self):
        results = self.client.get_item(TableName=self.TABLENAME,
                    Key={
                    "UserID": {"S": self.user_id}
                },
                    ProjectionExpression="Steps, DirStep"
                )
        return ""

    def getIngredNum(self):
        results = self.client.get_item(TableName=self.TABLENAME,
                    Key={
                    "UserID": {"S": self.user_id}
                },
                    ProjectionExpression="IngStep"
                )
        return results

    def getStepNum(self):
        results = self.client.get_item(TableName=self.TABLENAME,
                    Key={
                    "UserID": {"S": self.user_id}
                },
                    ProjectionExpression="DirStep"
                )
        return results

#helper class to conver a DynamoDB to JSON
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, decimal.Decimal):
            if o % 1 > 0:
                return float(o)
            else:
                return int(o)

        return super(DecimalEncoder, self).default(o)

